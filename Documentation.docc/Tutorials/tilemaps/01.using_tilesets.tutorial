@Tutorial(time: 30) {
    @Intro(title: "Using TileSets") {

        @Image(source: "fix-me.png")
    }
    @Section(title: "Introduction") {
        @ContentAndMedia {
            A tilemap is a grid of tiles used to create a game's layout. There are several
            benefits to using [`TileMapLayer`](https://docs.godotengine.org/en/stable/classes/class_TileMapLayer.html#class-TileMapLayer) nodes to design your
            levels
            @Image(source: "Tileset_cover.png", alt: "An example tileset featuring the Kenny's Abstract Platformer tileset")
        }
        First, they let you draw a layout by "painting" tiles onto a grid,
        which is much faster than placing individual [`Sprite2D`](https://docs.godotengine.org/en/stable/classes/class_Sprite2D.html#class-Sprite2D) nodes one by one. Second, they allow for larger levels
        because they are optimized for drawing large numbers of tiles.
        Finally, they allow you to add greater functionality to your tiles with
        collision, occlusion, and navigation shapes.
        
        To use TileMapLayer nodes, you will need to create a TileSet first. A TileSet is a
        collection of tiles that can be placed in a TileMapLayer node. After creating a
        TileSet, you will be able to place them [`using the TileMap editor`](doc:02.using_tilemaps).
        
        To follow this guide, you will need an image containing your tiles where every
        tile has the same size (large objects can be split into several tiles). This
        image is called a *tilesheet*. Tiles do not have to be square: they can be
        rectangular, hexagonal, or isometric (pseudo-3D perspective).
    }
    @Section(title: "Using a tilesheet") {
        @ContentAndMedia {
            This demonstration will use the following tiles taken from
            [Kenney's "Abstract Platformer" pack](https://kenney.nl/assets/abstract-platformer).
            We'll use this particular *tilesheet* from the set:

            @Image(source: "using_tilesets_kenney_abstract_platformer_tile_sheet.png", alt: "Tilesheet example with 64×64 tiles")
            
        }
        Download the attached *.zip* file and extract it in the **Files** app, the once ready continue back in Xogot.
        @Steps {
            @Step {
                Starting from the **Project Manager** press the **+** or **New Game** buttons to create a new project.
                
                Name the project whatever you like, we will use "Tiles Tutorial"
                @Image(source: fix-me.png)
            }
            @Step {
                Press **Create Other Node** and in the **All** tab, search for **TileMapLayer**, then *tap* it to create it.
                @Image(source: fix-me.png)
            }
            @Step {
                Select the new node and create a new TileSet resource in the **Inspector** by tapping `PickResource` and selecting `New TileSet`:
                @Image(source: "using_tilesets_create_new_tileset.png", alt: "Creating a new TileSet resource within the TileMapLayer node")
                
                >Tip: If the **Scope** dock is closed press the cross-hair icon in the upper right next to play to open it.
            }
            This will automatically open the TileMap editor dock on the bottom. We will explore these tabs in a bit.
            @Step {
                For now, click the value to unfold it in the
                inspector.
                @Image(source: fix-me.png)
            }
            > Tip:  The default tile shape is Square, but you can also choose Isometric,
            Half-Offset Square or Hexagon (depending on the shape of your tile images). If
            using a tile shape other than Square, you may also need to adjust the **Tile
            Layout** and **Tile Offset Axis** properties. Lastly, enabling the
            **Rendering > UV Clipping** toggle may be useful if you wish tiles to be clipped
            by their tile coordinates. This ensures tiles cannot draw outside their allocated
            area on the tilesheet.
            @Step {
                Set the tile size to 64×64 in the inspector to match the example tilesheet:
                @Image(source: "using_tilesets_specify_size_then_edit.png", alt: "Setting the tile size to 64×64 to match the example tilesheet")
            }
            >Important: If relying on automatic tiles creation (like we're about to do here), you must set the tile size **before** creating the *atlas*. The atlas will determine which tiles from the tilesheet can be added to a `TileMapLayer` node (as not every part of the image may be a valid tile).
            @Step {
                Press the little **+** icon next to `res://`. Then tap **Import Files** and navigate to your extracted archive. We want "tilesheet_complete.png" from inside the Tilesheet folder. Select it, and then press **Open**.
                @Image(source: fix-me.png)
            }
            @Step {
                With the `TileMapLayer`, open the **TileSet** panel at the bottom of the editor, then press and drag the
                tilesheet image onto the left half of the panel. This will automatically import the tileset image.
                @Image(source: "using_tilesets_create_tiles_automatically.png", alt: "Automatically creating tiles based on tilesheet image content")
            }
            This will automatically create tiles according to the tile size you specified
            earlier in the TileSet resource. This greatly speeds up initial tile setup.
            
            @Step {
                Let's get a better look at your tileset image by closing both the **Scope** (1) and **Scene Tree** panels (2).
                
                Then drag up on the pull handle to expand the **TileSet** panel (3).
                @Image(source: fix-me.png)
            }
            
            > When using automatic tile generation based on image contents, parts of the
            tilesheet that are *fully* transparent will not have tiles generated.

            @Step {
                You can select a tile and choose **Delete**  in the **Ellipsis** (**...**) menu to remove any tiles you don't want.
                @Image(source: fix-me.png)
            }
            If you wish to source tiles from several tilesheet images for a single `TileSet`,
            create additional atlases and assign textures to each of them before continuing.
            It is also possible to use one image per tile this way (although using
            tilesheets is recommended for better usability).
            @Step { 
                You can adjust properties for the atlas by opening the **Scope** (1) and selecting **Setup** (2) in the **Atlas Inspector** tab.
                @Image(source: "using_tilesets_properties.png", alt: "Adjusting TileSet atlas properties in the dedicated inspector (part of the TileSet panel)")
            }
            The following properties can be adjusted in the **Atlas Inspector**:

            * **ID:** The identifier (unique within this `TileSet`), used for sorting.
            * **Name:** The human-readable name for the atlas. *Use a descriptive name
            here for organizational purposes (such as "terrain", "decoration", etc).*
            * **Margins:** The margins on the image's edges that should not be selectable as
            tiles (in pixels). Increasing this can be useful if you download a tilesheet
            image that has margins on the edges (e.g. for attribution).
            * **Separation:** The separation between each tile on the atlas in pixels.
            Increasing this can be useful if the tilesheet image you're using contains
            guides (such as outlines between every tile).
            * **Texture Region Size:** The size of each tile on the atlas in pixels. In most
            cases, this should match the tile size defined in the TileMapLayer property
            (although this is not strictly necessary).
            * **Use Texture Padding:** If toggled, adds a 1-pixel transparent edge around
            each tile to prevent texture bleeding when filtering is enabled.
            It's recommended to leave this enabled unless you're running into rendering issues
            due to texture padding.

            > Note: changing texture margin, separation and region size may cause tiles to
            be lost (as some of them would be located outside the atlas image's
            coordinates), so only change if needed during `TileSet` setup.
            @Step {
                To regenerate tiles automatically from the tilesheet, use the
                 **More Details** icon (1), at the top of the **TileSet** editor, next to the **Select Mode** button and choose
                **Create Tiles in Non-Transparent Texture Regions** (2):
                @Image(source: "using_tilesets_recreate_tiles_automatically.png", alt: "Recreating tiles automatically after changing atlas properties")
            }
            >tip:The **Select Mode** button lets you change modes from individual tile selection to rectangle lasso selection. Pressing **Clear** will clear your tile selection.
            
            >Note: To make a tile selection you need to be in **Select**, you can change that in the **Atlas Inspector** dropdown by pressing **Setup** and choosing **Select**.
            
            @Step {
                Save your `TileMapLayer` scene by tapping the dropdown on the top of the screen and pressing **Save Scene**.
                @Image(source: fix-me.png)
            }
        }
    }
    @Section(title: "Using a collection of scenes") {
        @ContentAndMedia {
            You can also place actual *scenes* as tiles. This allows you to use
            any collection of nodes as a tile. For example, you could use scene tiles to
            place gameplay elements, such as shops the player may be able to interact with.
            You could also use scene tiles to place AudioStreamPlayer2Ds (for ambient
            sounds), particle effects, and more.
            @Image(source: fix-me.png)
        }
        
        > Warning: Scene tiles come with a greater performance overhead compared to atlases, as
        every scene is instanced individually for every placed tile. It's recommended to only use scene tiles when necessary. To draw sprites in a
        tile without any kind of advanced manipulation, use atlases instead.
        @Steps {
            For this example, we'll create a scene containing a `CPUParticles2D` root node.
            @Step {
                Tap the dropdown next to your scene name and press **New Scene**.
                @Image(source: fix-me.png)
            }
            @Step {
                Name the scene "cpu_particles" and select **Empty**, then press **Create**.
                @Image(source: fix-me.png)
            }
            @Step {
                Press **Create Other Node** and then in the **All** tab search for `CPUParticles2D` and tap on it to add it.
                @Image(source: fix-me.png)
            }
            @Step {
                Save this scene to a scene file in the dropdown (1), then switch to the scene containing the TileMapLayer node (2)
                @Image(source: fix-me.png)
            }
            @Step {
                Open the TileSet editor, and create a new **Scenes Collection** in the **Tiles** column. To do so, hit the **+** and select **Scenes Collection**
                
                @Image(source: "using_tilesets_creating_scene_collection.png", alt: "Creating a scenes collection in the TileSet editor")
            }
            @Step {
                Select this scenes collection then create a new scene slot by tapping **+**:
                @Image(source: "using_tilesets_scene_collection_create_scene_tile.png", alt: "Creating a scene tile after selecting the scenes collection in the TileSet editor")
            }
            @Step {
                In the pop-up window, select your newly saved `cpu_particles.tscn` file and press **select**.
                @Image(source: "using_tilesets_adding_scene_tile.png", alt: "Creating a scene slot, then loading a scene file into it in the TileSet editor")
            }
            Now that we have added a scene to our `TileSet` we should give it a descriptive name.
            @Step {
                Tap on the scene entry and change the **Name** in the **Atlas Inspector** tab to `CPU Particles`.
                @Image(source: fix-me.png)
            }
            You now have a scene tile in your `TileSet`. Once you switch to the **TileMap**
            editor, you'll be able to select it from the scenes collection and paint it like
            any other tile.
        }
    }
    @Section(title: "Merging several atlases into a single atlas") {
        @ContentAndMedia {
            Using multiple atlases within a single `TileSet` resource can sometimes be useful,
            but it can also be cumbersome in certain situations (especially if you're using
            one image per tile). Xogot allows you to merge several atlases into a single
            atlas for easier organization.
            @Image(source: fix-me.png)
        }
        
        @Steps {
            To do so, you must have more than one atlas created in the `TileSet` resource.
            
            For this example we will add a few new tilesets based on the Godot `icon.svg` file.
            @Step {
                Use the **Settings** "Cog" menu button located at the top of the list of
                atlases, then choose **Open Atlas Merging Tool**:
                
                @Image(source: "using_tilesets_open_atlas_merging_tool.png", alt: "Opening the atlas merging tool after creating multiple atlases")
            }
            @Step {
                This will open a dialog, in which you can select several atlases by tapping on them in the list on the left.
                
                > It can take time to load the resulting atlas, especially for large files, so it may take time to update your new atlas. Please be patient when selecting atlases to merge. Once ready the result will display in the right panel.
                @Image(source: "using_tilesets_atlas_merging_tool_dialog.png", alt: "Using the atlas merging tool dialog")
            }
            @Step {
                Choose **Merge** to merge the selected atlases into a single atlas image (which
                translates to a single atlas within the TileSet).
                
                You will need to give the merged file a name in the following pop-up window.
            }
            The unmerged atlases will be
            removed within the TileSet, but *the original tilesheet images will be kept on
            the filesystem*. If you don't want the unmerged atlases to be removed from the
            TileSet resource, toggle **Keep Original Atlases** before merging.
            
            > Tip: `TileSet` features a system of *tile proxies*. Tile proxies are a mapping
            table that allows notifying the TileMap using a given `TileSet` that a given
            set of tile identifiers should be replaced by another one. Tile proxies are automatically set up when merging different atlases, but
            they can also be set manually thanks to the **Manage Tile Proxies** dialog
            you can access using the **Settings** "Cog" menu mentioned above. Manually creating tile proxies may be useful when you changed an atlas ID or
            want to replace all tiles from an atlas by the ones from another atlas. 
        }
    }
    @Section(title: "Adding collision, navigation and occlusion to the TileSet") {
        @ContentAndMedia {
            We've now successfully created a basic `TileSet`. We could start using it in the
            `TileMapLayer` node now, but it currently lacks any form of collision detection.
            This means the player and other objects could walk straight through the floor or
            walls.
            @Image(source: "fix-me.png")
        }
        If you use 2D navigation, you'll also need
        to define navigation polygons for tiles to generate a navigation mesh that
        agents can use for pathfinding.

        Lastly, if you use lights or GPUParticles2D, you may
        also want your `TileSet` to be able to cast shadows and collide with particles.
        This requires defining occluder polygons for "solid" tiles on the `TileSet`.

        In the next few steps we will cover how to add a layer for these important features.
        
        @Steps {
            To be able to define collision, navigation and occlusion shapes for each tile,
            you will need to create a physics, navigation or occlusion layer for the TileSet
            resource first.
            @Step {
                Select the `TileMapLayer` node, click the `TileSet` property
                value in the inspector to edit it then tap `Array[0]` next to **Physics Layers** and choose
                **Add** in the upper-right:
            }
            @Step {
                If you also need navigation support, now is a good time to create a navigation layer by tapping `Array[0]` next to **Navigation Layers** and pressing **Add**:
                @Image(source: "using_tilesets_create_navigation_layer.png", alt: "Creating a navigation layer in the TileSet resource inspector (within the TileMapLayer node)")
            }
            If you need support for light polygon occluders, now is also a good time to create an occlusion layer.
            @Step {
                Tap **Rendering**, and then press `Array[0]` next to **Occlusion Layers** and press **Add**:
                @Image(source: "using_tilesets_create_occlusion_layer.png", alt: "Creating an occlusion layer in the TileSet resource inspector (within the TileMapLayer node)")
            }
            > Important:  Future steps in this tutorial are tailored to creating *collision polygons*,
                but the procedure for navigation and occlusion is very similar.
                Their respective polygon editors behave in the same way, so these steps are
                not repeated for brevity. The only caveat is that the tile's occlusion polygon property is part of a
                **Rendering** subsection in the **Atlas Inspector**. Make sure to unfold this
                section so you can edit the polygon.
            @Step {
                After creating a physics layer, you have access to the **Physics Layer** section
                in the TileSet atlas inspector:
                @Image(source: "using_tilesets_selecting_collision_editor.png", alt: "Opening the collision editor while in Select mode")
            }
            @Step {
                You can quickly create a rectangle collision shape by pressing F while
                the TileSet editor is focused. If the keyboard shortcut doesn't work, try
                clicking in the empty area around the polygon editor to focus it:
                @Image(source: "using_tilesets_using_default_rectangle_collision.png", alt: "Using default rectangle collision shape by pressing :kbd:`F`")
            }
            @Step {
                In this tile collision editor, you have access to all the 2D polygon editing tools:

                * Use the toolbar above the polygon to toggle between creating a new polygon,
                editing an existing polygon and removing points on the polygon. The "three vertical dots"
                menu button offers additional options, such as rotating and flipping the polygon.
                * Create new points by clicking and dragging a line between two points.
                * Remove a point by right-clicking it (or using the Remove tool described above
                and left-clicking).
                * Pan in the editor by middle-clicking or right-clicking. (Right-click panning
                can only be used in areas where there is no point nearby.)

                You can use the default rectangle shape to quickly create a triangle-shaped
                collision shape by removing one of the points:
                @Image(source: "using_tilesets_creating_triangle_collision.png", alt: "Creating a triangle collision shape by right-clicking one of the corners to remove it")
            }
            @Step {
                You can also use the rectangle as a base for more complex shapes by adding more points:
                @Image(source: "using_tilesets_drawing_custom_collision.png", alt: "Drawing a custom collision for a complex tile shape")
            }
            @Step {
                > Tip: If you have a large tileset, specifying the collision for each tile
                individually could take a lot of time. This is especially true as TileMaps
                tend to have many tiles with common collision patterns (such as solid blocks
                or 45-degree slopes). To apply a similar collision shape to several tiles
                quickly, use functionality to
                [`assign properties to multiple tiles at once`](doc:doc_using_tilemaps_assigning_properties_to_multiple_tiles).
            }
        }
    }
    @Section(title: "Assigning custom metadata to the TileSet's tiles") {
        @ContentAndMedia {
            You can assign custom data on a per-tile basis using *custom data layers*.
            This can be useful to store information specific to your game, such as the damage
            that a tile should deal when the player touches it, or whether a tile can be
            destroyed using a weapon.

            The data is associated with the tile in the TileSet: all instances of the placed
            tile will use the same custom data. If you need to create a variant of a tile
            that has different custom data, this can be done by <doc:creating an
            alternative tile <doc_using_tilesets_creating_alternative_tiles>> and changing
            the custom data for the alternative tile only.

            @Image(source: "using_tilesets_create_custom_data_layer.png", alt: "Creating a custom data layer in the TileSet resource inspector (within the TileMapLayer node)")
        }
        @Steps {
            @Step {

                @Image(source: "using_tilesets_custom_data_layers_example.png", alt: "Example of configured custom data layers with game-specific properties")
            }
            @Step {
                You can reorder custom data without breaking existing metadata: the TileSet
                editor will update automatically after reordering custom data properties.

                With the custom data layers example shown above, we're assigning a tile to have the
                `damage_per_second` metadata set to `25` and the `destructible` metadata
                to `false`:
                @Image(source: "using_tilesets_edit_custom_data.png", alt: "Editing custom data in the TileSet editor while in Select mode")
            }
            @Step {
                [`Tile property painting`](doc:doc_using_tilemaps_using_tile_property_painting)
                can also be used for custom data:
                @Image(source: "using_tilesets_paint_custom_data.png", alt: "Assigning custom data in the TileSet editor using tile property painting")
            }
            @Step {

            }
        }
    }
    @Section(title: "Creating terrain sets (autotiling)") {
        @ContentAndMedia {
            > This functionality was implemented in a different form as *autotiling* in Godot 3.x.
            Terrains are essentially a more powerful replacement of autotiles. Unlike
            autotiles, terrains can support transitions from one terrain to another, as
            a tile may define several terrains at once.Unlike before, where autotiles were a specific kind of tiles, terrains are
            only a set of properties assigned to atlas tiles. These properties are then
            used by a dedicated TileMap painting mode that selects tiles featuring
            terrain data in a smart way. This means any terrain tile can be either
            painted as terrain or as a single tile, like any other.

            A "polished" tileset generally features variations that you should use on
            corners or edges of platforms, floors, etc. While these can be placed manually,
            this quickly becomes tedious. Handling this situation with procedurally
            generated levels can also be difficult and require a lot of code.

            Godot offers *terrains* to perform this kind of tile connection automatically.
            This allows you to have the "correct" tile variants automatically used.

            Terrains are grouped into terrain sets. Each terrain set is assigned a mode from
            **Match Corners and Sides**, **Match Corners** and **Match sides**. They define how
            terrains are matched to each other in a terrain set.

            > The above modes correspond to the previous bitmask modes autotiles used in
            Godot 3.x: 2×2, 3×3 or 3×3 minimal. This is also similar to what
            the [Tiled](https://www.mapeditor.org/) editor features.

            Select the TileMapLayer node, go to the inspector and create a new terrain set within the TileSet *resource*:

            @Image(source: "using_tilesets_create_terrain_set.png", alt: "Creating a terrain set in the TileSet resource inspector (within the TileMapLayer node)")
        }
        @Steps {
            @Step {
                After creating a terrain set, you **must** create one or more terrains *within* the terrain set:
                @Image(source: "using_tilesets_create_terrain.png", alt: "Creating a terrain within the terrain set")
            }
            @Step {
                In the TileSet editor, switch to Select mode and click a tile. In the middle
                column, unfold the **Terrains** section then assign a terrain set ID and a
                terrain ID for the tile. `-1` means "no terrain set" or "no terrain", which
                means you must set **Terrain Set** to `0` or greater before you can set
                **Terrain** to `0` or greater.

                > Terrain set IDs and terrain IDs are independent from each other. They also
                start from `0`, not `1`.
                @Image(source: "using_tilesets_configure_terrain_on_tile.png", alt: "Configuring terrain on a single tile in the TileSet editor's Select mode")
            }
            @Step {
                After doing so, you can now configure the **Terrain Peering Bits** section which
                becomes visible in the middle column. The peering bits determine which tile will
                be placed depending on neighboring tiles. `-1` is a special value which refers
                to empty space.

                For example, if a tile has all its bits set to `0` or greater, it will only
                appear if *all* 8 neighboring tiles are using a tile with the same terrain ID.
                If a tile has its bits set to `0` or greater,
                but the top-left, top and top-right bits are set to `-1`, it will only appear
                if there is empty space on top of it (including diagonally).
                @Image(source: "using_tilesets_configure_terrain_peering_bits.png", alt: "Configuring terrain peering bits on a single tile in the TileSet editor's Select mode")
            }
            @Step {
                An example configuration for a full tilesheet may look as follows:
                @Image(source: "using_tilesets_terrain_example_tilesheet.png", alt: "Example full tilesheet for a sidescrolling game")
            }
            @Step {

                @Image(source: "using_tilesets_terrain_example_tilesheet_configuration.png", alt: "Example full tilesheet for a sidescrolling game with terrain peering bits visible")
            }
            @Step {

            }
        }
    }
    @Section(title: "Assigning properties to multiple tiles at once") {
        @ContentAndMedia {
            There are two ways to assign properties to multiple tiles at once.
            Depending on your use cases, one method may be faster than the other:
        }
    }
    @Section(title: "Using multiple tile selection") {
        @ContentAndMedia {
            If you wish to configure various properties on several tiles at once,
            choose the **Select** mode at the top of the TileSet editor:

            After doing this, you can select multiple tiles on the right column by holding
            Shift then clicking on tiles. You can also perform rectangle selection by
            holding down the left mouse button then dragging the mouse. Lastly, you can
            deselect tiles that were already selected (without affecting the rest of the
            selection) by holding Shift then clicking on a selected tile.

            You can then assign properties using the inspector in the middle column of the
            TileSet editor. Only properties that you change here will be applied to all
            selected tiles. Like in the editor's inspector, properties that differ on
            selected tiles will remain different until you edit them.

            With numerical and color properties, you will also see a preview of the
            property's value on all tiles in the atlas after editing a property:

            @Image(source: "using_tilesets_select_and_set_tile_properties.png", alt: "Selecting multiple tiles using the Select mode, then applying properties")
        }
        @Steps {
            @Step {

            }
        }
    }
    @Section(title: "Using tile property painting") {
        @ContentAndMedia {
            If you wish to apply a single property to several tiles at once,
            you can use the *property painting* mode for this purpose.

            Configure a property to be painted in the middle column, then
            click on tiles (or hold down the left mouse button) in the right column
            to "paint" properties onto tiles.

            @Image(source: "using_tilesets_paint_tile_properties.png", alt: "Painting tile properties using the TileSet editor")
        }
        @Steps {
            @Step {
                Tile property painting is especially useful with properties that are
                time-consuming to set manually, such as collision shapes:
                @Image(source: "using_tilesets_paint_tile_properties_collision.png", alt: "Painting a collision polygon, then left-clicking tiles to apply it")
            }
            @Step {

            }
        }
    }
    @Section(title: "Creating alternative tiles") {
        @ContentAndMedia {
            Sometimes, you want to use a single tile image (found only once within the
            atlas), but configured in different ways. For example, you may want to use the
            same tile image, but rotated, flipped, or modulated with a different color. This
            can be done using *alternative tiles*.

            > Tip: Since Godot 4.2, you don't have to create alternative tiles to rotate or
            flip tiles anymore. You can rotate any tile while placing it in the
            TileMap editor by using the rotation/flip buttons in the TileMap editor
            toolbar.

            To create an alternative tile, right-click a base tile in the atlas displayed by
            the TileSet editor, then choose **Create an Alternative Tile**:

            @Image(source: "using_tilesets_create_alternative_tile.png", alt: "Creating an alternative tile by right-clicking a base tile in the TileSet editor")
        }
        @Steps {
            @Step {
                If currently in Select mode, the alternative tile will already be selected
                for editing. If not currently in Select mode, you can still create alternative
                tiles, but you will need to switch to Select mode and select the alternative
                tile to edit it.

                If you don't see the alternative tile, pan over to the right of the atlas image,
                as alternative tiles always appear on the right of base tiles of a given atlas
                in the TileSet editor:
                @Image(source: "using_tilesets_configure_alternative_tile.png", alt: "Configuring an alternative tile after clicking it in the TileSet editor")
            }
            @Step {
                After selecting an alternative tile, you can change any properties using the
                middle column like you would on a base tile. However, the list of exposed
                properties is different compared to base tiles:

                * **Alternative ID:** The unique numerical identifier for this alternative tile.
                Changing it will break existing TileMaps, so be careful! This ID also controls
                the sorting in the list of alternative tiles displayed in the editor.
                * **Rendering > Flip H:** If `true`, the tile is horizontally flipped.
                * **Rendering > Flip V:** If `true`, the tile is vertically flipped.
                * **Rendering > Transpose:** If `true`, the tile is rotated 90 degrees
                *counter-clockwise* and then flipped vertically. In practice, this means that
                to rotate a tile by 90 degrees clockwise without flipping it, you should
                enable **Flip H** and **Transpose**. To rotate a tile by 180 degrees
                clockwise, enable **Flip H** and **Flip V**. To rotate a tile by 270 degrees
                clockwise, enable **Flip V** and **Transpose**.
                * **Rendering > Texture Origin:** The origin to use for drawing the tile. This
                can be used to visually offset the tile compared to the base tile.
                * **Rendering > Modulate:** The color multiplier to use when rendering the tile.
                * **Rendering > Material:** The material to use for this tile. This can be used
                to apply a different blend mode or custom shaders to a single tile.
                * **Z Index:** The sorting order for this tile. Higher values will make the tile
                render in front of others on the same layer.
                * **Y Sort Origin:** The vertical offset to use for tile sorting based on its Y
                coordinate (in pixels). This allows using layers as if they were on different
                height for top-down games. Adjusting this can help alleviate issues with
                sorting certain tiles. Only effective if **Y Sort Enabled** is `true` on
                the TileMapLayer node under **CanvasItem > Ordering**

                You can create an additional alternative tile variant by clicking the large "+"
                icon next to the alternative tile. This is equivalent to selecting the base tile
                and right-clicking it to choose **Create an Alternative Tile** again.

                > When creating an alternative tile, none of the properties from the base tile
                are inherited. You must set properties again on the alternative tile if you
                wish those to be identical on the base tile and the alternative tile.
            }
        }
    }
}
