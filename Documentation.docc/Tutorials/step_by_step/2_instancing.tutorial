@Tutorial(time: 20) {
    @Intro(title: "Creating instances") {

        @Image(source: "instantcing_multi_ball_scene.gif")
    }
    @Section(title: "Instancing: An Introduction") {
          
        In the previous part, we saw that a scene is a collection of nodes organized in
        a tree structure, with a single node as its root. You can split your project
        into any number of scenes. This feature helps you break down and organize your
        game's different components.
        
        You can create as many scenes as you'd like and save them as files with the
        `.tscn` extension, which stands for "text scene". The `label.tscn` file from
        the previous lesson was an example. We call those files "Packed Scenes" as they
        pack information about your scene's content.
        @ContentAndMedia {
            Here's an example of a ball. It's composed of a [`RigidBody2D`](https://docs.godotengine.org/en/stable/classes/class_RigidBody2D.html#class-RigidBody2D) node as its root named Ball, which allows the ball to fall
            and bounce on walls, a [`Sprite2D`](https://docs.godotengine.org/en/stable/classes/class_Sprite2D.html#class-Sprite2D) node, and a
            [`CollisionShape2D`](https://docs.godotengine.org/en/stable/classes/class_CollisionShape2D.html#class-CollisionShape2D).
            @Image(source: "instancing_ball_scene.png")
        }
        @ContentAndMedia {

                Once you have saved a scene, it works as a blueprint: you can reproduce it in other
                scenes as many times as you'd like. Replicating an object from a template like
                this is called **instancing**.
                @Image(source: "instancing_ball_instances_example.png")
        }
        As we mentioned in the previous part, instanced scenes behave like a node: the
        editor hides their content by default. When you instance the Ball, you only see
        the Ball node. Notice also how each duplicate has a unique name.

        Every instance of the Ball scene starts with the same structure and properties
        as `ball.tscn`. However, you can modify each independently, such as changing
        how they bounce, how heavy they are, or any property exposed by the source
        scene.
    }
    @Section(title: "In practice") {
        @ContentAndMedia {
            Let's use instancing in practice to see how it works in Xogot. We invite
            you to download the ball's sample project we prepared for you:
            [instancing_starter.zip](https://github.com/godotengine/godot-docs-project-starters/releases/download/latest-4.x/instancing_starter.zip).
        }
        @Steps {
            @Step {
                Extract the archive via the Files App. To do so, navigate to the archive and press on it. Once done, switch back to Xogot. 
                
                > Tip: To import it, you need to be in the main screen, also known as the **Project Manager**.
                The **Project Manager** is what you see when you first open Xogot. If a Xogot project is already open, press the down arrow next to your scene name, and press **Close Project**.
                
                In the Project Manager, press the **Folder** button to import the project.
                @Image(source: "instancing_import_button.png")
            }
            @Step {
                In the pop-up that appears navigate to the folder you extracted.
                Press the **Open** button to enter the project.
                @Image(source: "instancing_import_project_file.png")
            }
            > Important: A window might appear stating that this project was made in an older version of the Godot Engine. If that happens press "**Upgrade and Restart**"
            @Step {
                The project contains two packed scenes: `main.tscn`, containing walls against
                which the ball collides, and `ball.tscn`. The `main scene` should open
                automatically. 
                @Image(source: "instancing_main_scene.png")
            }
            @Step {
                If you're seeing an empty **3D** scene instead of the `main scene`, press the **2D** button at the top of the screen.
                @Image(source: "instancing_2d_scene_select.png")
            }
            Let's add a ball as a child of the `Main` node.
            @Step {
                In the Scene dock, select the `Main`
                node. Then, press the link icon at the top of the scene dock. 
                
                This button allows
                you to add an instance of a scene as a child of the currently selected node.
                @Image(source: "instancing_scene_link_button.png")
            }
            @Step {
                Double-tap the ball scene to instance it.
                @Image(source: "instancing_instance_child_window.png")
            }
            @Step {
                The ball appears in the top-left corner of the viewport.
                @Image(source: "instancing_ball_instanced.png")
            }
            @Step {
                With **Move Mode** enabled, press and drag it towards the center of the view.
                @Image(source: "instancing_ball_moved.png")
            }
            @Step {
                Play the game by pressing the **Play** icon. You should see it fall.
                @Image(source: "instancing_single_ball_scene.gif")
            }
            Now, we want to create more instances of the `Ball` node.
            @Step {
                With the ball still selected, press **Cmd + D** if you have a keyboard connected, otherwise press and hold the `Ball` node until the context menu appears and then press **Duplicate** to call the duplicate
                command.
                @Image(source: "instancing_ball_duplicated.png")
            }
            @Step {
                Press and drag to move the new ball to a different location.
                @Image(source: "instancing_move_duplicate.png")
            }
            @Step {
                You can repeat this process until you have several in the scene.
                @Image(source: "instancing_main_scene_with_balls.png")
            }
            @Step {
                Play the game again. You should now see every ball fall independently from one
                another. 
                
                This is what instances do. Each is an independent reproduction of a
                template scene.
                @Image(source: "instantcing_multi_ball_scene.gif")
            }
        }
    }
    @Section(title: "Editing scenes and instances") {
        @ContentAndMedia {
            There is more to instances. With this feature, you can:

            1. Change the properties of one ball without affecting the others using the
            Inspector.
            2. Change the default properties of every ball by opening the `ball.tscn` scene
            and making a change to the Ball node there. Upon saving, all instances of the
            Ball in the project will see their values update.

            > Changing a property on an instance always overrides values from the
            corresponding packed scene.
        }
        @Steps {
            Let's try this. 
            @Step {
                Double-tap `ball.tscn` in the FileSystem to open it.
                @Image(source: "instancing_ball_scene_open.png")
            }
            @Step {
                In the Scene dock on the left, select the Ball node. Then, with the **Scope** open and in the **Inspector** tab (1), press on the `PhysicsMaterial` property to expand it (2).
                @Image(source: "instancing_physics_material_expand.png")
            }
            @Step {
                Let's change it's `Bounce` property by tapping on the number field next to `Bounce`, typing `0.5` (1) in the pop-up window, and then closing the window by pressing *Enter* on a connected keyboard or the **Return key** (2).
                @Image(source: "instancing_property_bounce_updated.png")
            }
            @Step {
                Play the game and notice how all balls now bounce a lot
                more. As the Ball scene is a template for all instances, modifying it and saving
                causes all instances to update accordingly.

                Let's now adjust an individual instance. Head back to the Main scene by pressing
                on the corresponding tab above the viewport.
                @Image(source: "instancing_scene_tabs.png")
            }
            @Step {
                Select one of the instanced Ball nodes and, in the Inspector, set its
                Gravity Scale value to `10`.
                @Image(source: "instancing_property_gravity_scale.png")
            }
            @Step {
                Rerun the game and notice how this ball now falls much faster than the others.

                > Tip: You may notice you are unable to change the values of the `PhysicsMaterial`
                of the ball from the `Main` scene. This is because `PhysicsMaterial` is a *resource*, and needs
                to be made unique before you can edit it in a scene that is linking to its
                original scene. To make a resource unique for one instance, press the three dots on
                the Physics Material property in the **Scope** and press **Make Unique**
                in the context menu. 
                
                > Resources are another essential building block of Godot Engine games we will cover
                in a later lesson.
                @Image(source: "instancing_multi_bouncing_10_grav.gif")
            }
        }
    }
    @Section(title: "Scene instances as a design language") {
        Instances and scenes in Xogot and by extension Godot offer an excellent design language, setting the
        engine apart from others out there.

        We recommend dismissing architectural code patterns when making games with
        Xogot, such as Model-View-Controller (MVC) or Entity-Relationship diagrams.
        Instead, you can start by imagining the elements players will see in your game
        and structure your code around them.
        
        @ContentAndMedia {
            For example, you could break down a shooter game like so:

            @Image(source: "instancing_diagram_shooter.png")
        }
        
        You can come up with a diagram like this for almost any type of game. Each
        rectangle represents an entity that's visible in the game from the player's
        perspective. The arrows point towards the instantiator of each scene.

        Once you have a diagram, we recommend creating a scene for each element listed
        in it to develop your game. You'll use instancing, either by code or directly in
        the editor, to build your tree of scenes.

        Programmers tend to spend a lot of time designing abstract architectures and
        trying to fit components into it. Designing based on scenes makes development
        faster and more straightforward, allowing you to focus on the game logic itself.
        Because most game components map directly to a scene, using a design based on
        scene instantiation means you need little other architectural code.
        
        @ContentAndMedia {
            Here's the example of a scene diagram for an open-world game with tons of assets
            and nested elements:
            @Image(source: "instancing_diagram_open_world.png")
        }
        
        Imagine we started by creating the room. We could make a couple of different
        room scenes, with unique arrangements of furniture in them. Later, we could make
        a house scene that uses multiple room instances for the interior. We would
        create a citadel out of many instanced houses and a large terrain on which we
        would place the citadel. Each of these would be a scene instancing one or more sub-scenes.

        Later, we could create scenes representing guards and add them to the citadel.
        They would be indirectly added to the overall game world.
    }
    @Section(title: "Summary") {
        Instancing, the process of producing an object from a blueprint, has many handy
        uses. With scenes, it gives you:

        * The ability to divide your game into reusable components.
        * A tool to structure and encapsulate complex systems.
        * A language to think about your game project's structure in a natural way.
        
    }
}
