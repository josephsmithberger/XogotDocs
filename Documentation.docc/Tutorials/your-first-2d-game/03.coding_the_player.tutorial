@Tutorial(time: 30) {
    @Intro(title: "Coding the player") {
        In this lesson, we'll add player movement, animation, and set it up to detect
        collisions.
        
        @Image(source: player_flipped.png,
               alt: "alt text")
    }
    @Section(title: "Configuring input") {
        @ContentAndMedia {
            First, we need to check for input - is the player pressing a key or button?
            
            Input actions are defined in the Project Settings under "Input Map". Here, 
            you can define custom events and assign different keys, mouse events, or 
            other inputs to them. For this game, we will map a thumbstick to the four 
            directions.
            
        }
        @Steps {
            @Step {
                First, tap on the **...** toolbar button in the upper-right corner
                of Xogot and tap **Settings** (2) to open the *Project Settings* dialog.
                
                @Image(source: project-settings.png)  
            }
            @Step {
                In *Project Settings*, tap the dropdown arrow next to **General** and 
                select **Input Map**
                
                @Image(source: settings_input_map.png)
            }
            @Step {
                For this game, we have 4 direction inputs to check. 
                
                Tap the **+** button in the upper-left corner of the **Input Map**
                dialog to create a new input action.
                
                @Image(source: add_input_map.png)
            }
            @Step {
                In the *Create New Input Action* dialog, type "move_right" and then tap **Add**.
                
                Repeat this to add `move_left`, `move_up`, and `move_down` actions.
                
                @Image(source: create_input_map.png)
            }
            @Step {
                We need to assign input events to these new actions.  Tap the `move_right` action (1)
                on the left side of the dialog to select it.
                
                Then, tap the **+** icon (2) in the upper-right corner of the **Input Map** dialog
                to create a new input event. 
                
                @Image(source: add_input_event.png)
            }
            @Step {
                We'll use the right thumbstick we enabled when we set up the project to control 
                the `Player` direction.
                
                To configure thumbstick directions, tap **Keyboard Keys** and select **Joypad Axes** 
                from the dropdown.
                
                @Image(source: joypad_axes.png)
            }
            @Step {
                The right thumbstick maps to joypad axes 2 and 3.
                
                For the `move_right` action, select **Joypad Axis 2 + (Right Stick Right, Joystick 1 Right)**
                and tap **Create**
                
                @Image(source: right_stick_right.png)
            }
            @Step {
                We now have `move_right` configured as an action for the right thumbstick. Repeat these steps 
                to map **Right Stick Left** to `move_left`, **Right Stick Up** to `move_up`, and 
                **Right Stick Down** to `move_down`.   When you are done, you can tap **Close** 
                to dismiss the **Input Map** dialog.
                
                > Note: We only mapped one action to each input action, but you can map joystick buttons
                > or directions, multiple keys, or mouse buttons to the same input action.
                
                @Image(source: input_map_complete.png)
            }
        }
    }
    @Section(title: "Creating a script") {
        @ContentAndMedia {
                We need to add some functionality that we can't get from a built-in
                node, so we'll add a script. 
        }
        @Steps {
            @Step {
                Select the `Player` and tap the Script toolbar button at the top of the 
                Scene Tree.  It's the one that looks like a scroll.
                    
                @Image(source: add_script.png)
            }
            @Step {
                In the "Attach Node Script" popup, you can leave the default settings alone. 
                
                Just tap **Create** to create a new `player.gd` script using the default template.
                                
                @Image(source: attach_script.png)
            }
            @Step {
                Start by declaring the member variables this object will need. Insert these 
                two variable definitions near the top of the script after `extends Area2D`.
                
                > Note:  Everything after the `#` on each line is a comment.  These can be 
                > omitted, or you can include them as a note to help you, or anyone else who might
                > look at the code in the future, understand why the code is there. 
                                
                @Code(name: "player.gd", file: player-01.gd, previousFile: player-00.gd)
            }
            @Step {
                Using the `export` keyword on the first variable `speed` allows us to set
                its value in the Inspector. This can be handy for values that you want to be
                able to adjust just like a node's built-in properties. 
                
                Tap on the `Player` node and you'll see the property now appears in the 
                Inspector in a new section with the name of the script. Remember, if you 
                change the value here, it will override the value written in the script.
                            
                @Image(source: inspector_speed.png)
            }
            @Step {
                Your `player.gd` script should already contain
                a `_ready()` and a `_process()` function.
                If you didn't select the default template when you created the script,
                be sure to define these functions while following the lesson.
                
                The `_ready()` function is called when a node enters the scene tree, which is
                a good time to find the size of the game window.
                
                @Code(name: "player.gd", file: player-02.gd)
            }
            @Step {
                Now we can use the `_process()` function to define what the player will do.
                `_process()` is called every frame, so we'll use it to update elements of our
                game, which we expect will change often. For the player, we need to (1) Check for input,
                (2) Move in the given direction, and (3) Play the appropriate animation.
                
                We start by setting the `velocity` to `(0, 0)` - by default, the player should not be moving. 
                
                @Code(name: "player.gd", file: player-03.gd)
            }
            @Step {
                Then we check each input and add/subtract from the
                `velocity` to obtain a total direction. You can detect whether a key is pressed 
                using `Input.is_action_pressed()`, which returns `true` if it's pressed or `false` 
                if it isn't.
                
                For example, if you hold `right` and `down` at the same time, the resulting 
                `velocity` vector will be `(1, 1)`.
                
                @Code(name: "player.gd", file: player-04.gd)
            }
            @Step {
                In this case, since we're adding a horizontal and a vertical movement, the
                player would move *faster* diagonally than if it just moved horizontally.
                We can prevent that if we *normalize* the velocity, which means we set its
                *length* to `1`, then multiply by the desired speed. This means no more fast
                diagonal movement.

                > Tip: If you've never used vector math before, or need a refresher, you can
                > see an explanation of vector usage in Godot at :ref:`doc_vector_math`.
                > It's good to know but won't be necessary for the rest of this tutorial.
                
                @Code(name: "player.gd", file: player-05.gd)
            }
            @Step { 
               We also check whether the player is moving so we can call `play()` or
               `stop()` on the AnimatedSprite2D.
               
                > Tip: `$` is shorthand for `get_node()`. So in this code,
                > `$AnimatedSprite2D.play()` is the same as
                > `get_node("AnimatedSprite2D").play()`. 
                > 
                > In GDScript, `$` returns 
                > the node at the relative path from the current node, or returns 
                > `null` if the node is not found. Since AnimatedSprite2D is a 
                > child of the current node, we can use `$AnimatedSprite2D`.
                
                @Code(name: "player.gd", file: player-06.gd)
            }
            @Step { 
                Now that we have a movement direction, we can update the player's position. We
                can also use `clamp()` to prevent it from leaving the screen. *Clamping* a
                value means restricting it to a given range. Add this code to the bottom of
                the `_process` function (make sure it's not indented under the `else`).
                
                > Tip: The `delta` parameter in the `_process()` function refers to the *frame
                > length* - the amount of time that the previous frame took to complete.
                > Using this value ensures that your movement will remain consistent even
                > if the frame rate changes.
                
                @Code(name: "player.gd", file: player-07.gd)
            }
            @Step { 
                
                Long-press the `Play` button in the upper-right corner of the app and 
                select **Run Current Scene** to test the `Player`. Confirm you can move 
                the player around the screen in all directions.
                
                > Warning: If you get an error in the "Debugger" panel that says
                > `Attempt to call function 'play' in base 'null instance' on a null
                > instance` this likely means you spelled the name of the AnimatedSprite2D node
                > wrong. Node names are case-sensitive and `$NodeName` must match the name you 
                > see in the scene tree.
                
                @Image(source: run_current_scene.png)
            }
        }
    }
    @Section(title: "Choosing animations") {
        @ContentAndMedia {
            Now that the player can move, we need to change which animation the
            AnimatedSprite2D is playing based on its direction. 
        }
        @Steps {
            @Step {
                We have the "walk" animation, which shows the player walking to the right. 
                This animation should be flipped horizontally using the `flip_h` property for 
                left movement. We also have the "up" animation, which should be flipped 
                vertically with `flip_v` for downward movement. 
                
                Let's place this code at the end of the `_process()` function.
                
                @Code(name: "player.gd", file: player-08.gd, previousFile: player-07.gd)
                
                @Comment {
                    > Note: The boolean assignments in the code example are a common shorthand for
                    > programmers. Since we're doing a comparison test (boolean) and also
                    > *assigning* a boolean value, we can do both at the same time. Consider
                    > this code versus the one-line boolean assignment above:
                    > 
                    > if velocity.x < 0:
                    >     $AnimatedSprite2D.flip_h = true
                    > else:
                    >     $AnimatedSprite2D.flip_h = false
                }
            }
            @Step {
                Play the scene again and check that the animations are correct in each of the
                directions.
                
                > Tip: A common mistake here is to type the names of the animations wrong. The
                > animation names in the SpriteFrames panel must match what you type in
                > the code. If you named the animation `"Walk"`, you must also use a
                > capital "W" in the code.
                
                @Image(source: player_flipped.png)
            }
            @Step {
                When you're sure the movement is working correctly, add this line to
                `_ready()`, so the player will be hidden when the game starts.
                
                @Code(name: "player.gd", file: player-09.gd)
            }
        }
    }
    @Section(title: "Preparing for collisions") {
        @ContentAndMedia {
            We want `Player` to detect when it's hit by an enemy, but we haven't made any
            enemies yet! That's OK, because we're going to use Godot's *signal*
            functionality to make it work.
        }
        @Steps {
            @Step {
                Add "`signal hit`" to the top of the script after `extends Area2D`. 
                
                This defines a custom signal called "hit" that we will have our player emit
                (send out) when it collides with an enemy. 
                
                @Code(name: "player.gd", file: player-10.gd, previousFile: player-09.gd)
            }
            @Step {
                We will use an `Area2D` signal to detect the collision. 
                Select the `Player` node and open the Inspector.  Notice there are four tabs at 
                the top of the Inspector.  
                
                Tap the second tab from the left - the one that looks like two squares connected
                by a curve - to open the Signals tab.  Notice our custom "hit" signal is 
                at the top of the list!
                
                @Image(source: player_signals.png)
                
            }
            @Step {
                Since our enemies are going to
                be `RigidBody2D` nodes, we want the `body_entered(body: Node2D)` signal. This
                signal will be emitted when a body contacts the player. 
                
                Tap the `body_entered(body: Node2D)` signal and the **Connect a Signal** dialog appears.
                
                @Image(source: player_signal_connection.png)
            }
            @Step {
                You don't need to change the default settings right now.  
                
                Tap **Connect**.
                
                @Image(source: player_signal_body_entered.png)
            }
            @Step {
                Xogot will create a function with that exact name the signal expects 
                directly in script for you. 
                
                @Comment {
                    Note the icon indicating that a signal is connected to this function; this does
                    not mean the function exists, only that the signal will attempt to connect to a function
                    with that name, so double-check that the spelling of the function matches exactly!
                    
                    @Image(source: player_signal_connection.png)
                }
                
                @Code(name: "player.gd", file: player-11.gd)
            }
            @Step {
                Replace the `pass` line with this code in the `_on_body_entered` function.
                
                Whenever an enemy hits the player, we will `hide` the `Player` sprite and
                the `hit` signal will be emitted. 
                
                @Code(name: "player.gd", file: player-12.gd)
            }
            @Step {
                We need to disable the player's collision so that we don't trigger the `hit` 
                signal more than once; however, disabling the area's collision shape can cause 
                an error if it happens in the middle of the engine's collision processing. 
                
                Using `set_deferred()` tells Godot to wait to disable the shape until it's
                safe to do so.
                
                @Code(name: "player.gd", file: player-13.gd)
            }
            @Step {
                The last piece is to add a function we can call to reset the player when
                starting a new game.
                
                @Code(name: "player.gd", file: player-14.gd)
            }
        }
    }
}
