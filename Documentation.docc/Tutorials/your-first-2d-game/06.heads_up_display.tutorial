@Tutorial(time: 30) {
    @Intro(title: "Heads up display") {
        The final piece our game needs is a User Interface (UI) to display things like
        the score, a "game over" message, and a restart button.  
                
        @Image(source: hud_play_hero.png)
    }
    @Section(title: "Creating the HUD ") {
        @ContentAndMedia {
            "HUD" stands for "heads-up display", an informational display that
            appears as an overlay on top of the game view.
        }
        @Steps {
            @Step {
                Create a new empty scene named "hud" and tap **Create Other Node** to add a new 
                [`CanvasLayer`](https://docs.godotengine.org/en/stable/classes/class_canvaslayer.html#class-canvaslayer)
                named "**HUD**".
                
                > Note: The [`CanvasLayer`](https://docs.godotengine.org/en/stable/classes/class_canvaslayer.html#class-canvaslayer)
                node lets us draw our UI elements on a layer above the rest of the game, 
                so that the information it displays isn't covered up by any game elements like the player 
                or mobs.
                
                @Image(source: hud_canvas.png)
            }
            The basic node for UI elements is
            [`Control`](https://docs.godotengine.org/en/stable/classes/class_control.html#class-control). 
            To create our UI, we'll use two types of 
            [`Control`](https://docs.godotengine.org/en/stable/classes/class_control.html#class-control)
            nodes: 
            [`Label`](https://docs.godotengine.org/en/stable/classes/class_label.html#class-label) and 
            [`Button`](https://docs.godotengine.org/en/stable/classes/class_button.html#class-button). 
            @Step {
                
                First, let's add two [`Label`](https://docs.godotengine.org/en/stable/classes/class_label.html#class-label) nodes: 
                **Score** will be changed by `ScoreTimer`, and **Message** will display messages 
                such as "Game Over" or "Get Ready!"
                
                @Image(source: hud_labels.png)
            }
            @Step {
                Let's also add a [`Button`](https://docs.godotengine.org/en/stable/classes/class_button.html#class-button) 
                named **StartButton** that can be tapped to begin the game and a 
                [`Timer`](https://docs.godotengine.org/en/stable/classes/class_timer.html#class-timer) 
                named **MessageTimer** to control how long messages are displayed.  
                
                > IMportant: Your HUD scene should now look like this:
                
                @Image(source: hud_scene.png)
            }
            @Step {
                Tap on the `Score` label and type a number into the `Text` field in the
                Inspector. 
                
                @Image(source: hud_font_orig.png)
            }
            > The default font for `Control` nodes is small and doesn't scale
            well. 
            
            There is a font file included in the game assets called
            *Xolonium-Regular.ttf*. To use this font, do the following:
            @Step {
                Scroll the Inspector down to the **Control** section and tap **Theme Overrides**.
                Tap **Pick Resource** (1) next to **Font** and choose **Load** (2).  Browse into the 
                **fonts** folder and Select the *Xolonium-Regular.ttf* file.
                
                @Image(source: custom_font_load_font.png)
            }
            @Step {
                In "Theme Overrides" set the "Font Size" to `64`. Repeat
                these **Font** and **Font Size** changes with with the
                `Message` and `StartButton` nodes.
                
                @Image(source: custom_font_size.png)
            }
            @Step {
               The image for this step shows the Anchor Presets pane; While you can drag the nodes to place them manually, for more precise placement, we will use "Anchor Presets".
                
                > Note: **Anchors:** `Control` nodes have a position and size,
                > but they also have anchors. Anchors define the origin -
                > the reference point for the edges of the node.
                
                @Image(source: ui_anchor.png)
            }
            Throughout the next four sections, we will arrange the UI nodes and set the `MessageTimer` properties.
        }
    }
    @Section(title: "Score") {
        @ContentAndMedia {
            Use the following settings to configure and position the Score label:
            
            |   |  |
            | - | ------- |
            | 1 | Set the `text` to **0**.|
            | 2 | Set the `Horizontal Alignment` and `Vertical Alignment` to **Center**.|
            | 3 | Set `Anchor Preset` to **Center Top**.|
            
            @Image(source: hud_score.png)
        }
        @Steps {
        }
    }
    @Section(title: "Message") {
        @ContentAndMedia {
            Use the following settings to configure and position the Message label:
            
            |   |  |
            | - | ------- |
            |   | Set the `text` to "**Save the Axolotl**". | 
            |   | Set the "Horizontal Alignment" and "Vertical Alignment" to **Center**. |
            |   | Set "Autowrap Mode" to `Word`, otherwise the label will stay on one line. |
            | 1 | Under "Control - Layout" set "Size X"  to **480** to use the entire width of the screen. |
            | 2 | Set "Anchor Preset" to **Center**. |
            
            @Image(source: hud_message.png)
        }
        @Steps {
        }
    }
    @Section(title: "StartButton") {
        @ContentAndMedia {
            
            |    |  |
            | - | ----------- |
            |   | Set the `text` to **Start**. |
            | 1 | Under "Control - Transform", set "Size X" to **200** and "Size Y" to **100** to add a little bit more padding between the border and text. |
            | 2 | Under "Control - Layout - Transform", set "Position Y" to **580**. |
            | 3 | Set "Anchor Preset" to **Center Bottom**. |
            
            @Image(source: hud_button.png)
        }
        @Steps {
        }
    }
    @Section(title: "MessageTimer") {
        @ContentAndMedia {
            
            |    |  |
            | - | ----------- |
            | 1 | Set the "Wait Time" to **2**. |
            | 2 | Set the "One Shot" property to "On" |
            
            @Image(source: hud_timer.png)
        }
        @Steps {
        }
    }
    @Section(title: "Coding the UI") {
        @ContentAndMedia {
            Now let's write some code to script the UI.
        }
        @Steps {
            @Step {
                Add a script to `HUD`.  This script will not need `_ready` or `_process`
                methods, so we can toggle off the **Use Template** option.
                @Code(name: "hud.gd", file: hud-00.gd)
            }
            @Step {
                Near the top of the script, define a new `signal` named `start_game`
                to notify the `Main` node when the button has been pressed.
                
                @Code(name: "hud.gd", file: hud-01.gd, previousFile: hud-00.gd)
            }
            Let's add a function to temporarily show a message like "Get Ready!"
            @Step {
                Add the following code to change `$Message.text` to be our `text` variable and then display it using `.show()`. We also start the timer.
                @Code(name: "hud.gd", file: hud-02.gd)
            }
            @Step {
                This function is called when the player loses. It will show "Game Over" for 2
                seconds, then return to the title screen and, after a brief pause, show the
                "Start" button.
                
                > Tip: When you need to pause for a brief time, an alternative to using a
                > Timer node is to use the SceneTree's `create_timer()` function. This
                > can be very useful to add delays such as in the above code, where we
                > want to wait some time before showing the "Start" button.
                >
                >In this example we don't need to define a new timer node in the tree in advance and instead make one at execution.
                
                @Code(name: "hud.gd", file: hud-03.gd)
            }
            @Step {
                Add an `update_score` method to `HUD` that can be called to update the score's `.text` attribute.
                
                @Code(name: "hud.gd", file: hud-04.gd)
            }
            @Step {
                Connect the `pressed()` signal of `StartButton` and the `timeout()`
                signal of `MessageTimer` to new Receiver Methods in the `HUD` node.
                
                > Important: Once connected, add this code to the `_on_start_button_pressed()` and `_on_message_timer_timeout()` functions:
                @Code(name: "hud.gd", file: hud-06.gd)
            }
        }
    }
    @Section(title: "Connecting HUD to Main") {
        @ContentAndMedia {
            Now that we're done creating the `HUD` scene, we need to connect the `HUD` functionality 
            to our `Main` script. 
            
            This requires a few additions to the `Main` scene.
        }
        @Steps {
            @Step {
                Switch back to the `Main` scene by tapping the Scene dropdown (1) 
                at the top of the app, tapping **Select Scene** (2) and choosing **main** (3).
                
                > Tip: If you have closed the `Main` scene, you can reopen it by double-tapping 
                `main.tscn` in the File Pad. 
                
                @Image(source: hud_main.png)
            }
            @Step {
                Select the root node, `Main`, and Instantiate `HUD` as a child scene (1) like you did the `Player` scene. 
                
                > Important: When you have added the HUD, the scene tree should look like this. Now would be a good time to make sure you didn't miss anything.
                
                @Image(source: hud_main_child.png)
            }
            @Step {
                With the `HUD` selected, open the Inspector to the Signals tab and tap `start_game`.
                
                @Image(source: hud_start_signal.png)
            }
            @Step {
                Go to the "Connect a Signal" dialog, tap the `Main` node to select it, then tap **Pick** 
                in the "Receiver Method" field and select the `new_game()` method.  Tap **Pick Method**
                and then tap **Connect** to finish wiring up the signal.  
                
                The connected method name will now appear as `â†’..::new_game()` below the `start_game` 
                signal in the Signals pad.
                
                @Image(source: hud_start_connected.png)
            }
            Verify that the signal connection icon now appears next to `func new_game()` in the script.
            @Step {
                In `new_game()`, update the score display and show the "Get Ready" message:
                
                @Code(name: "main.gd", file: main-10.gd, previousFile: main-09.gd)
            }
            @Step {
                In `game_over()` we need to call the corresponding `HUD` function:
                
                @Code(name: "main.gd", file: main-11.gd)
            }
            @Step {
                Finally, add this to `_on_score_timer_timeout()` to keep the display in sync
                with the changing score:
                
                @Code(name: "main.gd", file: main-12.gd)
            }
            @Step {
                
                Make sure you've removed the call to `new_game()` from
                 `_ready()` if you haven't already, otherwise
                 your game will start automatically.
                
                @Image(source: hud_play.png)
            }
            Now you're ready to play! Tap the "Play" button at the top of the app.
        }
    }
    @Section(title: "Removing old creeps") {
        @ContentAndMedia {
            If you play until "Game Over" and then start a new game right away, the creeps
            from the previous game may still be on the screen. It would be better if they
            all disappeared at the start of a new game. We just need a way to tell *all* the
            mobs to remove themselves. 
            
            We can do this with the "group" feature.
        }
        @Steps {
            @Step {
                Switch to the `mob` scene and select the root `Mob` node.  Open the Inspector and 
                switch to the Groups tab (1) - the third tab with the three boxes, next to the Signals tab. 
                
                Tap **Add Group** (2) to open the "Create New Group" dialog.
                
                @Image(source: hud_group_tab.png)
            }
            @Step {
                Name the group `mobs` and tap "Ok" to add a new scene group.
                
                @Image(source: hud_group_dialog.png)
            }
            @Step {
                
                Now all mobs will be in the "mobs" group.
                
                @Image(source: hud_mobs_group.png)
            }
            @Step {
                We can then add this line to the `new_game()` function in `Main`.
                
                The `call_group()` function calls the named function on every node in a
                group - in this case we are telling every mob to delete itself.
                
                @Code(name: "main.gd", file: main-13.gd, previousFile: main-12.gd)
            }
        }
    }
}
